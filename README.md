# Hello 12-factor Django

## 12-factor principles

[I. Codebase](https://12factor.net/codebase)

One codebase tracked in revision control, many deploys

[II. Dependencies](https://12factor.net/dependencies)

Explicitly declare and isolate dependencies

[III. Config](https://12factor.net/config)

Store config in the environment

[IV. Backing services](https://12factor.net/backing-services)

Treat backing services as attached resources

[V. Build, release, run](https://12factor.net/build-release-run)

Strictly separate build and run stages

[VI. Processes](https://12factor.net/processes)

Execute the app as one or more stateless processes

[VII. Port binding](https://12factor.net/port-binding)

Export services via port binding

[VIII. Concurrency](https://12factor.net/concurrency)

Scale out via the process model

[IX. Disposability](https://12factor.net/disposability)

Maximize robustness with fast startup and graceful shutdown

[X. Dev/prod parity](https://12factor.net/dev-prod-parity)

Keep development, staging, and production as similar as possible

[XI. Logs](https://12factor.net/logs)

Treat logs as event streams

[XII. Admin processes](https://12factor.net/admin-processes)

Run admin/management tasks as one-off processes

## Things we did to make Django 12-factor-y

#### Project setup

- Install Python, Git, and the Heroku CLI
- Create our accounts on Heroku
- Start a new Django project called 'hello'
- Initialize our git repo and make our initial commit

#### requirements.txt

- Create a file called `requirements.txt`
- List our dependencies there (e.g. `django`)

We want to list down our dependencies so they can be installed with a single command. `pip install -r requirements.txt`. Your teammates (and your future self) will thank you.

#### Configure gunicorn

- Create the gunicorn configuration file (`gunicorn.conf`)
- Test that gunicorn works (`gunicorn --config gunicorn.conf hello.wsgi`)
- Add `gunicorn` to `requirements.txt`

Django comes with a development server that you start using `python manage.py runserver`. This server is meant only for development purposes on your local machine, and is therefore unsuitable for use in production. This is where gunicorn comes in.

Green Unicorn (gunicorn) is a server that _is_ suitable for production. We configured it to bind to IP `0.0.0.0:5000` by default, so when you run gunicorn, you're able to see your app being served on that address.

Unfortunately, gunicorn does not run on Windows, so you're just going to have to trust me that it will work on your Linux server.

#### Procfile

- Create a file called `Procfile` (no file extension)
- Add the `web` process

The Procfile is where you define the types of processes your web app will be running. In our case we have a single process called "web" where we run the gunicorn server.

In more complicated apps, you can have other processes like "worker" for background processing or "clock" for scheduled tasks. You can name the other processes anything you want, but the "web" process is special, so it has to be "web".

#### Environment variables

- Configure `django-environ`
- Add `.env` file
- Add `django-environ` to `requirements.txt`

You really don't want to be hard coding some of your settings in `settings.py`. Settings like `SECRET_KEY` or your database configuration are sensitive information that you don't want to be sharing to anyone who has access to your repo. Other settings like `DEBUG` or `ALLOWED_HOSTS` on the other hand are just more convenient if you load them from the environment instead of hardcoding them.

We configure django-environ to load some of our settings from environment variables. Great! But _setting up_ environment variables manually is a pain, so we configure django-environ to load our variables from a file called `.env`. This file is local to your machine, it's not committed to the repo, so you can store any variable you want and it won't be shared with anyone else.

#### Configure static files

- Add `STATIC_ROOT` setting to `settings.py`
- Test that it works by running `python manage.py collectstatic`

Static files are files that are static. üòÅ

Unlike a regular page which is generated by Django, static files are just files stored on the server. Some examples of these are javascript and css files. To serve static files, Django first needs to collect them with the `collectstatic` management command. Django will copy all of our static files to the directory set as the `STATIC_ROOT`.

#### Whitenoise

- Configure `whitenoise` to serve static files
- Add `whitenoise` to `requirements.txt`

Another production quirk! Django isn't optimized for serving static files. This is the whole point of the `collectstatic` management command. Django just collects and puts all of them in a single folder so that they can be served by something else. WhiteNoise is that something else.

We configure WhiteNoise by simply adding the `WhiteNoiseMiddleware` to our `MIDDLEWARE_CLASSES` setting. Now whenever a request for a static file comes in, WhiteNoise will take care of it.

#### Configure logging

- Add `LOGGING` setting to `settings.py`

In our particular deployment setup, we want to be able to see the logs with the `heroku logs` command, so we configure logging to print logs to stdout. To do this, we add the `LOGGING` setting which I seriously just copy paste from project to project. If you want to learn more about how logging works in Django (or Python in general), you can check out the [Django docs](https://docs.djangoproject.com/en/dev/topics/logging/).

#### Postgres

- Add `pscyopg2` to `requirements.txt`

Though Django supports a multitude of database backends, you'll probably be using Postgres. Heroku automatically sets up a Postgres database for us when we create our app, but Django needs the `psycopg2` library to connect to Postgres databases. So we simply add `psycopg2` to our `requirements.txt` file.

Ideally you'd also be using Postgres during development because it's good to have your development and production environments to be similar, but we didn't do this to save time.

### Deploying your app

Now your app is ready to be deployed to Heroku. We use Heroku because it's the fastest way to publish your web app on the Internet that I could find.

First you create your app.

```
$ heroku apps:create
```

(This command might ask for your credentials if it's your first time using it.)

If the command was successful, then your app should be created on Heroku, and a new git remote called `heroku` should be added to your repo.

```
$ git remote
heroku
```

Before we push our app to Heroku, let's first configure those environment variables.

```
$ heroku config:set SECRET_KEY='something-super-secret' ALLOWED_HOSTS='.herokuapp.com'
```

Now we can push our app to Heroku!

```
$ git push heroku master
```

If all went well, then you should now be able to visit your web app. A shortcut to open your web browser to your app is to run `heroku open`.

```
$ heroku open
```

Of course, we didn't have any controllers or views in our app so you'll see a 404, but Django comes with a nifty admin app so we can try and visit that. Just add `admin/` to the end of the URL.

Before we can login though, we need to migrate the database and create our super user. Locally, we would have run `python manage.py migrate` to migrate our database. So how do we migrate our database on Heroku?

```
$ heroku run python manage.py migrate
```

Simple as that. Now to create our superuser.

```
$ herok run python manage.py createsuperuser
```

You should now be able to login to the admin.

## Finally

We're done!

This workshop is meant to introduce you to configuring your applications so that they're easy to deploy anywhere, may it be on your laptop, your teammate's workstation, Heroku, or even your own virtual private server (VPS). You now have a template for a production ready Django application.
